import { NextResponse } from "next/server";

// Custom words that should be considered correct
// Add your custom words here
const customWords = [
  "NextJS",
  "Jodit",
  "akas",
  "ami",
  "tumi",
  "Ami",
  "Tumi",
  "Akas",
  "shadcn",
  "TypeScript",
  "JavaScript",
  "React",
  "useState",
  "useEffect",
  "useCallback",
  "useMemo",
  "API",
  "JSON",
  "HTML",
  "CSS",
  "UI",
  "UX",
  "frontend",
  "backend",
  "fullstack",
  "webpack",
  "npm",
  "yarn",
  "pnpm",
  "ESLint",
  "Prettier",
  "Tailwind",
  "shadcn-ui",
  "GitHub",
  "VSCode",
  "Node.js",
  "MongoDB",
  "PostgreSQL",
  "MySQL",
  "Redis",
  "Docker",
  "Kubernetes",
  "AWS",
  "Azure",
  "GCP",
  "Vercel",
  "Netlify",
  "Heroku",
  "Firebase",
  "Supabase",
  "Prisma",
  "GraphQL",
  "REST",
  "API",
  "JWT",
  "OAuth",
  "CORS",
  "HTTPS",
  "SSL",
  "TLS",
  "DNS",
  "CDN",
  "SEO",
  "PWA",
  "SPA",
  "SSR",
  "SSG",
  "ISR",
  "CSR",
  "hydration",
  "middleware",
  "serverless",
  "microservices",
  "monorepo",
  "polyrepo",
  "CI/CD",
  "DevOps",
  "agile",
  "scrum",
  "kanban",
  "MVP",
  "POC",
  "refactoring",
  "debugging",
  "testing",
  "TDD",
  "BDD",
  "E2E",
  "integration",
  "unit",
  "mocking",
  "stubbing",
  "linting",
  "bundling",
  "minification",
  "optimization",
  "performance",
  "accessibility",
  "responsive",
  "mobile-first",
  "desktop-first",
  "breakpoints",
  "viewport",
  "flexbox",
  "grid",
  "animations",
  "transitions",
  "transforms",
  "gradients",
  "shadows",
  "typography",
  "iconography",
  "branding",
  "wireframes",
  "mockups",
  "prototypes",
  "user-stories",
  "personas",
  "journey-mapping",
  "A/B-testing",
  "analytics",
  "metrics",
  "KPIs",
  "ROI",
  "conversion",
  "funnel",
  "retention",
  "engagement",
  "onboarding",
  "gamification",
  "personalization",
  "localization",
  "internationalization",
  "i18n",
  "l10n",
  "RTL",
  "LTR",
  "UTF-8",
  "ASCII",
  "Unicode",
  "regex",
  "algorithms",
  "data-structures",
  "Big-O",
  "complexity",
  "scalability",
  "maintainability",
  "readability",
  "documentation",
  "comments",
  "changelog",
  "versioning",
  "semantic-versioning",
  "semver",
  "releases",
  "hotfixes",
  "patches",
  "features",
  "bugfixes",
  "enhancements",
  "deprecation",
  "migration",
  "upgrade",
  "downgrade",
  "rollback",
  "deployment",
  "staging",
  "production",
  "development",
  "localhost",
  "environment",
  "variables",
  "configuration",
  "secrets",
  "credentials",
  "authentication",
  "authorization",
  "permissions",
  "roles",
  "users",
  "sessions",
  "cookies",
  "tokens",
  "encryption",
  "hashing",
  "salting",
  "validation",
  "sanitization",
  "escaping",
  "injection",
  "XSS",
  "CSRF",
  "security",
  "vulnerability",
  "penetration",
  "audit",
  "compliance",
  "GDPR",
  "CCPA",
  "privacy",
  "terms",
  "conditions",
  "disclaimer",
  "copyright",
  "license",
  "open-source",
  "proprietary",
  "commercial",
  "enterprise",
  "startup",
  "freelance",
  "consultant",
  "contractor",
  "employee",
  "remote",
  "hybrid",
  "onsite",
  "collaboration",
  "communication",
  "meetings",
  "standups",
  "retrospectives",
  "planning",
  "estimation",
  "velocity",
  "burndown",
  "backlog",
  "epics",
  "stories",
  "tasks",
  "subtasks",
  "tickets",
  "issues",
  "bugs",
  "features",
  "improvements",
  "technical-debt",
  "refactoring",
  "optimization",
  "performance",
  "monitoring",
  "logging",
  "alerting",
  "dashboards",
  "reports",
  "insights",
  "trends",
  "patterns",
  "anomalies",
  "outliers",
  "statistics",
  "data-science",
  "machine-learning",
  "AI",
  "ML",
  "deep-learning",
  "neural-networks",
  "algorithms",
  "models",
  "training",
  "inference",
  "prediction",
  "classification",
  "regression",
  "clustering",
  "recommendation",
  "personalization",
  "automation",
  "scripting",
  "tooling",
  "utilities",
  "helpers",
  "libraries",
  "frameworks",
  "packages",
  "modules",
  "components",
  "hooks",
  "providers",
  "contexts",
  "reducers",
  "actions",
  "dispatchers",
  "selectors",
  "middleware",
  "interceptors",
  "guards",
  "decorators",
  "annotations",
  "metadata",
  "reflection",
  "serialization",
  "deserialization",
  "marshalling",
  "unmarshalling",
  "parsing",
  "formatting",
  "templating",
  "rendering",
  "compilation",
  "transpilation",
  "polyfills",
  "shims",
  "fallbacks",
  "graceful-degradation",
  "progressive-enhancement",
  "backwards-compatibility",
  "forwards-compatibility",
  "cross-platform",
  "cross-browser",
  "responsive",
  "adaptive",
  "fluid",
  "elastic",
  "scalable",
  "maintainable",
  "extensible",
  "modular",
  "reusable",
  "composable",
  "declarative",
  "imperative",
  "functional",
  "object-oriented",
  "procedural",
  "event-driven",
  "reactive",
  "asynchronous",
  "synchronous",
  "concurrent",
  "parallel",
  "sequential",
  "batch",
  "streaming",
  "real-time",
  "offline",
  "online",
  "connectivity",
  "network",
  "bandwidth",
  "latency",
  "throughput",
  "caching",
  "memoization",
  "lazy-loading",
  "eager-loading",
  "prefetching",
  "preloading",
  "code-splitting",
  "tree-shaking",
  "dead-code-elimination",
  "minification",
  "compression",
  "gzip",
  "brotli",
  "optimization",
];

export async function GET() {
  try {
    return NextResponse.json({
      words: customWords,
      count: customWords.length,
      message: "Custom dictionary loaded successfully",
    });
  } catch (error) {
    console.error("Error loading custom dictionary:", error);
    return NextResponse.json(
      {
        error: "Failed to load custom dictionary",
        words: [],
        count: 0,
      },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const { word } = await request.json();

    if (!word || typeof word !== "string") {
      return NextResponse.json(
        { error: "Invalid word provided" },
        { status: 400 }
      );
    }

    // In a real application, you would save this to a database
    // For now, we'll just return success
    return NextResponse.json({
      message: `Word "${word}" added to custom dictionary`,
      word: word.toLowerCase(),
    });
  } catch (error) {
    console.error("Error adding word to dictionary:", error);
    return NextResponse.json(
      { error: "Failed to add word to dictionary" },
      { status: 500 }
    );
  }
}
